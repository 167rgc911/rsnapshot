#!/usr/bin/perl

########################################################################
#                                                                      #
# rsnapshot                                                            #
#                                                                      #
# by Nathan Rosenquist                                                 #
# based on code originally by Mike Rubel                               #
#                                                                      #
# http://rsnapshot.sourceforge.net/                                    #
#                                                                      #
# rsnapshot comes with ABSOLUTELY NO WARRANTY.  This is free software, #
# and you are welcome to redistribute it under certain conditions.     #
# See the GNU General Public Licence for details.                      #
#                                                                      #
########################################################################

# attention vi users: set ts=4 sw=4

########################
### STANDARD MODULES ###
########################

use strict;
use warnings;
use Getopt::Std;

#########################
### DECLARE VARIABLES ###
#########################

my $VERSION = '0.9.4';

# default configuration file
my $config_file	= '/etc/rsnapshot.conf'; 

# assume the config file syntax is OK unless we encounter problems
my $file_syntax_ok = 1;

# count the lines in the config file, so we can pinpoint errors more precisely
my $file_line_num = 0;

# hash to hold variables from the configuration file
my %config_vars;

# array of hash_refs containing the source -> destination backup points
my @snapshot_points;

# "intervals" are user defined time periods (i.e. hourly, daily)
# this array holds hash_refs containing the name of the interval,
# and the number of snapshots to keep of it
my @intervals;

# which of the intervals are we operating on?
# if we defined hourly, daily, weekly ... hourly = 0, daily = 1, weekly = 2
my $interval_num;

# the highest possible number for the current interval context
# if we are working on hourly, and hourly is set to 6, this would be
# equal to 5 (since we start at 0)
my $interval_max;

# this is the name of the previous interval, in relation to the one we're
# working on. i.e. if we're operating on weekly, this should be "daily"
my $prev_interval;

# same as $interval_max, except for the previous interval.
# this is used to determine which of the previous snapshots to pull from
# i.e. cp -al hourly.$prev_interval_max/ daily.0/
my $prev_interval_max;

# command line flags
my %opts; 

# command or interval to execute
my $cmd;

# parse config file and exit
my $do_configtest = 0;

# show the shell commands being executed
my $verbose = 0;

# turn verbose on, but don't execute the commands
my $test = 0;
 
##############################
### CORE PROGRAM STRUCTURE ###
##############################

# GET COMMAND LINE OPTIONS 
getopt('c', \%opts);
getopts('vt', \%opts);
$cmd = $ARGV[0];

# ALTERNATE CONFIG FILE
if (defined($opts{'c'}) && ( -f $opts{'c'} ))	{
	$config_file = $opts{'c'};
}

# VERBOSE?
if (defined($opts{'v'}))	{
	$verbose = 1;
}

# TEST?
if (defined($opts{'t'}))	{
	$test = 1;
	$verbose = 1;
}

# COMMAND LINE ARGS 
if ( ! $cmd )	{
	show_usage();
	exit(0);
}
if ($cmd eq 'help')	{
	show_help();
}
if ($cmd eq 'configtest')	{
	$do_configtest = 1;
} 
if ($cmd eq 'version')	{
	print "rsnapshot $VERSION\n";
	exit(0);
}
if ($cmd eq 'version_only')	{
	print $VERSION;
	exit(0);
}
 
# PARSE CONFIG FILE 
if ( -f $config_file )	{
	open(CONFIG, $config_file) or bail("Could not open config file \"$config_file\"");
	while (my $line = <CONFIG>)	{
		chomp($line);
		
		# count line numbers
		$file_line_num++;
		
		# assume the line is formatted incorrectly
		my $line_syntax_ok = 0;
		
		# ignore comments
		if ($line =~ /^#/)	{ next; }
		
		# ignore blank lines
		if ($line =~ /^$/)	{ next; }
		
		# ignore lines that are pure white space
		if ($line =~ /^\s*$/)	{ next; }
		
		# parse line
		my ($var, $value, $value2) = split(/\t+/, $line, 3);
		
		# warn about entries we don't understand, and prevent the program from running
		if (!defined($var) or !defined($value))	{
			print STDERR "Error in $config_file on line $file_line_num: $line\n";
			$file_syntax_ok = 0;
			next;
		}
		
		# SNAPSHOT_ROOT
		if ($var eq 'snapshot_root')	{
			# remove the trailing slash
			if ($value =~ /\/$/)	{
				chop($value);
				$config_vars{'snapshot_root'} = $value;
				
			# there is no trailing slash to remove
			} else	{
				$config_vars{'snapshot_root'} = $value;
			}
			$line_syntax_ok = 1;
			next;
		}
		
		# REQUIRED EXTERNAL COMMANDS
		foreach my $command (qw( rsync mkdir touch cp mv rm ))	{
			if ($var eq "cmd_$command")	{
				if ( -x $value )	{
					$config_vars{"cmd_$command"} = $value;
					$line_syntax_ok = 1;
				} else	{
					bail("Could not find $value, please fix cmd_$command in $config_file");
				}
			}
		}
		# OPTIONAL EXTERNAL COMMANDS
		foreach my $command (qw( ssh ))	{
			if ($var eq "cmd_$command")	{
				if ( -x $value )	{
					$config_vars{"cmd_$command"} = $value;
					$line_syntax_ok = 1;
				} else	{
					bail("Could not find $value, please fix cmd_$command in $config_file");
				}
			}
		}
		
		# INTERVALS
		if ($var eq 'interval')	{
			if (!defined($value))		{ bail("Interval can not be blank"); }
			if ($value !~ m/^[\w\d]+$/)	{ bail("\"$value\" is not a valid entry"); }
			
			if (!defined($value2))		{ bail("\$value\" number can not be blank"); }
			if ($value2 !~ m/^\d+$/)	{ bail("$value2 is not an integer"); }
			if ($value2 == 0)			{ bail("\"$value\" can not be 0"); }
			
			my %hash;
			$hash{'interval'}	= $value;
			$hash{'number'}		= $value2;
			push(@intervals, \%hash);
			$line_syntax_ok = 1;
		}
		
		# BACKUP points
		if ($var eq 'backup')	{
			my $src = $value;
			my $dest = $value2;
			
			if ( !defined($config_vars{'snapshot_root'}) )	{	bail("snapshot_root needs to be defined before backup points"); }
			
			# we have a valid file path
			if ( -d "$src" )	{
				$line_syntax_ok = 1;
				
			# this wasn't on the filesystem
			# let's see if it matches a remote pattern we know about
			} else	{
				
				# if it's an ssh path, make sure we have ssh
				if ( $src =~ /^.*?\@.*?:\/.*$/ )	{
					if (!defined($config_vars{'cmd_ssh'}))	{
						bail("Cannot handle $src, cmd_ssh not defined in $config_file");
					}
					$line_syntax_ok = 1;
					
				# if it's anonymous rsync, we're ok
				} elsif ( $src =~ /^rsync:\/\/.*$/ )	{
					$line_syntax_ok = 1;
					
				# we don't know what this is, it must be bad
				} else	{
					bail("Source directory \"$src\" doesn't exist");
				}
				
			}
			if ($dest =~ /^\//)	{ bail("Full paths not allowed for backup destinations"); }
			
			# make sure we don't backup the backup!
			if ($config_vars{'snapshot_root'} =~ $src)	{
				opendir(SRC, $src) or bail("Could not open $src");
				readdir(SRC);	# .
				readdir(SRC);	# ..
				
				while (my $dir = readdir(SRC))	{
					if ("$src/$dir" ne "$config_vars{'snapshot_root'}")	{
						my %hash;
						$hash{'src'}	= "$src/$dir";
						$hash{'dest'}	= "$dest/$dir";
						push(@snapshot_points, \%hash);
					}
				}
				closedir(SRC);
			} else	{
				my %hash;
				$hash{'src'}	= $src;
				$hash{'dest'}	= $dest;
				push(@snapshot_points, \%hash);
			}
		}
		
		# CHECK TO SEE THAT WE UNDERSTOOD THIS LINE
		# IF NOT, WARN THE USER, AND PREVENT THE PROGRAM FROM EXECUTING
		if ($line_syntax_ok == 0)	{
			print STDERR "Error in $config_file on line $file_line_num: $line\n";
			$file_syntax_ok = 0;
		}
	}
	close(CONFIG);
	
	# CONFIG TEST?
	if ($do_configtest && $file_syntax_ok)	{
		print "Syntax OK\n";
		exit(0);
	}
} else	{
	print STDERR "Config file \"$config_file\" does not exist or is not readable.\n";
	exit(-1);
}

# BAIL OUT HERE IF THERE WERE ERRORS IN THE CONFIG FILE
if ($file_syntax_ok == 0)	{
	print STDERR "-----------------------------------\n";
	print STDERR "Errors were found in $config_file, rsnapshot can not continue.\n";
	print STDERR "If you think an entry looks right, make sure you don't have\n";
	print STDERR "spaces where only tabs should be.\n";
	exit(-1);
}
 
# CREATE THE SNAPSHOT ROOT IF IT DOESN'T EXIST, AND CHANGE THE FILE PERMISSIONS TO 0700
if ( ! -d "$config_vars{'snapshot_root'}" )	{
	if ($verbose)	{ print "$config_vars{'cmd_mkdir'} -p $config_vars{'snapshot_root'}\n"; }
	if ($test == 0)	{
		system( $config_vars{'cmd_mkdir'}, '-p', "$config_vars{'snapshot_root'}" );
	}
	if ( ! -d "$config_vars{'snapshot_root'}" )	{
		bail("Unable to create $config_vars{'snapshot_root'},\nPlease make sure you have the right permissions.");
	}
	
	if ($verbose)	{ print "chmod 0700 $config_vars{'snapshot_root'}\n"; }
	if ($test == 0)	{
		chmod( 0700, "$config_vars{'snapshot_root'}" )
			or bail("Could not change permissions on $config_vars{'snapshot_root'}\nPlease make sure you have the right permissions.");
	}
}
 
# FIGURE OUT WHICH INTERVAL WE'RE RUNNING, AND HOW IT RELATES TO THE OTHERS 
# THEN RUN THE ACTION FOR THE CHOSEN INTERVAL
my $i = 0;
foreach my $i_ref (@intervals)	{
	if ($$i_ref{'interval'} eq $cmd)	{
		$interval_num = $i;
		
		if ($$i_ref{'number'} > 0)	{
			$interval_max = $$i_ref{'number'} - 1;
		} else	{
			bail("$$i_ref{'interval'} can not be set to 0");
		}
		
		last;
	}
	
	# this WILL be previous next time through
	$prev_interval = $$i_ref{'interval'};
	
	if ($$i_ref{'number'} > 0)	{
		$prev_interval_max = $$i_ref{'number'} - 1;
	} else	{
		bail("$$i_ref{'interval'} can not be set to 0");
	}
	
	$i++;
}
undef($i);

if (!defined($interval_num))	{
	bail("Interval \"$cmd\" unknown, check $config_file");
}

# RUN THE BACKUP
if ($interval_num == 0)	{
	# if this is the most frequent interval, actually do the backups here
	backup_interval($cmd);
	
} else	{
	# this is not the most frequent unit, just rotate
	rotate_interval($cmd, $prev_interval);
}

# if we got this far, assume success
exit(0);

###################
### SUBROUTINES ###
###################

sub backup_interval	{
	my $interval = shift(@_);
	
	# this should never happen
	if (!defined($interval))	{ bail('backup_interval() expects an argument'); }
	
	# ROTATE DIRECTORIES
	#
	# remove oldest directory
	if ( -d "$config_vars{'snapshot_root'}/$interval.$interval_max" )	{
		
		if ($verbose)	{ print "$config_vars{'cmd_rm'} -rf $config_vars{'snapshot_root'}/$interval.$interval_max/\n"; }
		if ($test == 0)	{
			system( $config_vars{'cmd_rm'}, '-rf', "$config_vars{'snapshot_root'}/$interval.$interval_max/" );
		}
	}
	
	# rotate the middle ones
	for (my $i=($interval_max-1); $i>0; $i--)	{
		if ( -d "$config_vars{'snapshot_root'}/$interval.$i" )	{
			
			if ($verbose)	{
				print "$config_vars{'cmd_mv'} $config_vars{'snapshot_root'}/$interval.$i/ $config_vars{'snapshot_root'}/$interval." . ($i+1) . "/\n";
			}
			if ($test == 0)	{
				system( $config_vars{'cmd_mv'}, "$config_vars{'snapshot_root'}/$interval.$i/", ("$config_vars{'snapshot_root'}/$interval." . ($i+1) . '/') );
			}
		}
	}
	
	# hard link (except for directories) .0 over to .1
	if ( -d "$config_vars{'snapshot_root'}/$interval.0" )	{
		
		if ($verbose)	{ print "$config_vars{'cmd_cp'} -al $config_vars{'snapshot_root'}/$interval.0/ $config_vars{'snapshot_root'}/$interval.1/\n"; }
		if ($test == 0)	{
			system( $config_vars{'cmd_cp'}, '-al', "$config_vars{'snapshot_root'}/$interval.0/", "$config_vars{'snapshot_root'}/$interval.1/" );
		}
		
	}
	
	# SYNC LIVE DATA TO $interval.0
	foreach my $sp_ref (@snapshot_points)	{
		my $src;
		
		# append a trailing slash if it's a directory
		if ((-d "$$sp_ref{'src'}") && ($$sp_ref{'src'} !~ /\/$/))	{
			$src = $$sp_ref{'src'} . '/';
		} else	{
			$src = $$sp_ref{'src'};
		}
		
		# create missing parent directories inside the $interval.x directory
		my @dirs = split(/\//, $$sp_ref{'dest'});
		pop(@dirs);
		
		# don't mkdir unless we have to
		my $destpath = "$config_vars{'snapshot_root'}/$interval.0/" . join('/', @dirs);
		if ( ! -e "$destpath" )	{
			if ($verbose)	{ print "$config_vars{'cmd_mkdir'} -p $destpath/\n"; }
			if ($test == 0)	{
				system( $config_vars{'cmd_mkdir'}, '-p', "$destpath/" );
			}
		}
		
		# if this is a user@host:/path, use ssh
		if ($src =~ /^.*?\@.*?:\/.*$/)	{
			if ($verbose)	{ print "$config_vars{'cmd_rsync'} -al --delete --numeric-ids --devices --rsh=$config_vars{'cmd_ssh'} $src $config_vars{'snapshot_root'}/$interval.0/$$sp_ref{'dest'}\n"; }
			if ($test == 0)	{
				system( $config_vars{'cmd_rsync'}, '-al', '--delete', '--numeric-ids', '--devices', "--rsh=$config_vars{'cmd_ssh'}", $src, "$config_vars{'snapshot_root'}/$interval.0/$$sp_ref{'dest'}" );
			}
			
		# anonymous rsync
		} elsif ($src =~ /^rsync:\/\/.*$/)	{
			if ($verbose)	{ print "$config_vars{'cmd_rsync'} -alq --delete --numeric-ids --devices $src $config_vars{'snapshot_root'}/$interval.0/$$sp_ref{'dest'}\n"; }
			if ($test == 0)	{
				system( $config_vars{'cmd_rsync'}, '-alq', '--delete', '--numeric-ids', '--devices', $src, "$config_vars{'snapshot_root'}/$interval.0/$$sp_ref{'dest'}" );
			}
			
		# local filesystem
		} else	{
			if ($verbose)	{ print "$config_vars{'cmd_rsync'} -al --delete --numeric-ids --devices $src $config_vars{'snapshot_root'}/$interval.0/$$sp_ref{'dest'}\n"; }
			if ($test == 0)	{
				system( $config_vars{'cmd_rsync'}, '-al', '--delete', '--numeric-ids', '--devices', $src, "$config_vars{'snapshot_root'}/$interval.0/$$sp_ref{'dest'}" );
			}
		}
	}
	
	# update mtime of $interval.0 to reflect snapshot time
	if ($verbose)	{ print "$config_vars{'cmd_touch'} $config_vars{'snapshot_root'}/$interval.0/\n"; }
	if ($test == 0)	{
		system( $config_vars{'cmd_touch'}, "$config_vars{'snapshot_root'}/$interval.0/" );
	}
}

sub rotate_interval	{
	my $interval		= shift(@_);
	my $prev_interval	= shift(@_);
	
	# this should never happen
	if (!defined($interval) or !defined($prev_interval))	{
		bail('rotate_interval() expects 2 arguments');
	}
	
	# ROTATE DIRECTORIES
	#
	# delete the oldest one
	if ( -d "$config_vars{'snapshot_root'}/$interval.$interval_max" )	{
		if ($verbose)	{ print "$config_vars{'cmd_rm'} -rf $config_vars{'snapshot_root'}/$interval.$interval_max/\n"; }
		if ($test == 0)	{
			system( $config_vars{'cmd_rm'}, '-rf', "$config_vars{'snapshot_root'}/$interval.$interval_max/" );
		}
	}
	
	# rotate the middle ones
	for (my $i=($interval_max-1); $i>=0; $i--)	{
		if ( -d "$config_vars{'snapshot_root'}/$interval.$i" )	{
			if ($verbose)	{ print "$config_vars{'cmd_mv'} $config_vars{'snapshot_root'}/$interval.$i/ $config_vars{'snapshot_root'}/$interval." . ($i+1) . "/\n"; }
			if ($test == 0)	{
				system( $config_vars{'cmd_mv'}, "$config_vars{'snapshot_root'}/$interval.$i/", ("$config_vars{'snapshot_root'}/$interval." . ($i+1) . '/') );
			}
		}
	}
	
	# hard link (except for directories) previous interval over to .0
	if ( -d "$config_vars{'snapshot_root'}/$prev_interval.$prev_interval_max" )	{
		if ($verbose)	{ print "$config_vars{'cmd_cp'} -al $config_vars{'snapshot_root'}/$prev_interval.$prev_interval_max/ $config_vars{'snapshot_root'}/$interval.0/\n"; }
		if ($test == 0)	{
			system( $config_vars{'cmd_cp'}, '-al', "$config_vars{'snapshot_root'}/$prev_interval.$prev_interval_max/", "$config_vars{'snapshot_root'}/$interval.0/" );
		}
	}
}

sub bail	{
	my $str = shift(@_);
	print STDERR $str . "\n";
	exit(-1);
} 
 
sub show_help	{
	show_usage();
	
	print<<HERE;

rsnapshot is a filesystem snapshot utility. It can take incremental
snapshots of local and remote filesystems for any number of machines.

rsnapshot comes with ABSOLUTELY NO WARRANTY.  This is free software,
and you are welcome to redistribute it under certain conditions.
See the GNU General Public Licence for details.

Options:
    -v verbose - show shell commands being executed
    -t test    - show shell commands that would have been executed
    -c [file]  - specify alternate config file (-c /path/to/file)
HERE
	
	exit(0);
}

sub show_usage	{
	print "rsnapshot $VERSION\n";
	print "Usage: rsnapshot [-v] [-t] [-c /alt/config/file] <interval>|configtest|help|version\n";
	print "Type \"man rsnapshot\" for full details.\n";
} 
 
#####################
### PERLDOC / POD ###
#####################
 
=pod 
 
=head1 NAME

rsnapshot - remote filesystem snapshot utility

=head1 SYNOPSIS

B<rsnapshot> [B<-v>] [B<-t>] [B<-c> /alt/config/file] [command]

=head1 DESCRIPTION

B<rsnapshot> is a filesystem snapshot utility. It can take incremental
snapshots of local and remote filesystems for any number of machines.

Local filesystem snapshots are handled with rsync. Secure remote
connections are handled with B<rsync(1)> over B<ssh(1)>, while
anonymous rsync connections simply use an rsync server. Both remote
and local transfers depend on rsync.

B<rsnapshot> saves much more disk space than you might imagine. The amount
of space required is roughly the size of one full backup, plus a copy
of each additional file that is changed. B<rsnapshot> makes extensive
use of hard links, so if the file doesn't change, the next snapshot is
simply a hard link to the exact same file.

B<rsnapshot> will typically be invoked as root by a cron job, or series
of cron jobs. It is possible, however, to run as any arbitrary user
with an alternate configuration file.

All important options are specified in a configuration file, which is
located by default at B</etc/rsnapshot.conf>, although an alternate
one can be specified on the command line. There are also additional
options which can be passed on the command line.

The command line options are as follows:

=over 4

B<-v> verbose, show shell commands being executed

B<-t> test, show shell commands that would be executed

B<-c> specify an alternate config file

=back

=head1 CONFIGURATION

B</etc/rsnapshot.conf> is the default configuration file. All parameters
in this file must be seperated by tabs. B</etc/rsnapshot.conf.default>
can be used as a syntactically valid reference.

It is recommended that you copy B</etc/rsnapshot.conf.default> to
B</etc/rsnapshot.conf>, and then modify B</etc/rsnapshot.conf> to suit
your needs. What follows here is a list of allowed parameters:

=over 4

B<snapshot_root> local filesystem path to save all snapshots

B<cmd_rsync>     full path to rsync

B<cmd_ssh>       full path to ssh

B<cmd_mkdir>     full path to mkdir

B<cmd_touch>     full path to touch

B<cmd_cp>        full path to cp

B<cmd_mv>        full path to mv

B<cmd_rm>        full path to rm

B<interval>      [name] [number]

=over 4

"name" refers to the name of this interval (i.e. hourly, daily). "number"
is the number of snapshots for this type of interval that will be stored.
The value of "name" will be the command passed to B<rsnapshot> to perform
this type of backup.

Example: B<interval hourly 6>

[root@localhost]# B<rsnapshot hourly>

For this example, every time this is run, the following will happen:

<snapshot_root>/hourly.5/ will be deleted, if it exists.

<snapshot_root>/hourly.{1,2,3,4} will all be rotated +1, if they exist.

<snapshot_root>/hourly.0/ will be copied to <snapshot_root>/hourly.1/
using hard links.

Each backup point in <snapshot_root>/hourly.0/ will be rsynced with the
backup points specified in this config file later.

Intervals must be specified in the config file in order, from most
frequent to least frequent. The first entry is the one which will be
synced with the backup points. The subsequent intervals (i.e. daily,
weekly, etc) simply rotate, with each higher interval pulling from the
one below it for its .0 directory.

Example:

=over 4

B<interval  hourly 6>

B<interval  daily  7>

B<interval  weekly 4>

=back

daily.0/ will be copied from hourly.5/, and weekly.0/ will be copied from daily.6/

hourly.0/ will be rsynced directly from the filesystem.

=back

B<backup>  /local/path/                localhost/path/

B<backup>  root@example.com:/path/     example.com/path/

B<backup>  rsync://example.com/path2/ example.com/path2/

=over 4

Examples:

B<backup /etc/     etc/>

=over 4

Backs up /etc/ to <snapshot_root>/<interval>.0/etc/ using rsync on the local filesystem

=back

B<backup root@example.com:/home/ example.com/home/>

=over 4

Backs up root@example.com:/home/ to <snapshot_root>/<interval>.0/example.com/home/
using rsync over ssh

=back

B<backup rsync://example.com/pub/  example.com/pub/>

=over 4

Backs up rsync://example.com/pub/ to <snapshot_root>/<interval>.0/example.com/pub/
using an anonymous rsync server

=back

=back

=back

Remember that tabs must seperate all elements, and that
there must be a trailing slash on the end of every directory.

A hash mark (#) on the beginning of a line is treated
as a comment.

Putting it all together (an example file):

=over 4

# THIS IS A COMMENT, TO REMIND YOU THAT TABS MUST SEPERATE ALL ELEMENTS

B<snapshot_root>   /.snapshots/

B<cmd_rsync>       /usr/bin/rsync

B<cmd_ssh>         /usr/bin/ssh

B<cmd_mkdir>       /bin/mkdir

B<cmd_touch>       /bin/touch

B<cmd_cp>          /bin/cp

B<cmd_mv>          /bin/mv

B<cmd_rm>          /bin/rm

B<interval>        hourly  6

B<interval>        daily   7

B<interval>        weekly  7

B<interval>        monthly 3

B<backup>  /etc/                        localhost/etc/

B<backup>  /home/                       localhost/home/

B<backup>  root@foo.com:/etc/           example.com/etc/

B<backup>  root@foo.com:/home/          example.com/home/

B<backup>  root@mail.foo.com.com:/home/ mail.foo.com/home/

B<backup>  rsync://example.com/pub/     example.com/pub/

=back

=head1 USAGE

B<rsnapshot> can be used by any user, but for system-wide backups
you will probably want to run it as root. Since backups tend to
get neglected if human intervention is required, the preferred
way is to run it from cron.

Here is an example crontab entry, assuming that intervals B<hourly>,
B<daily>, B<weekly> and B<monthly> have been defined in B</etc/rsnapshot.conf>

=over 4

B<0 */4 * * *         /usr/local/bin/rsnapshot hourly>

B<50 23 * * *         /usr/local/bin/rsnapshot daily>

B<40 23 1,8,15,22 * * /usr/local/bin/rsnapshot weekly>

B<30 23 1 * *         /usr/local/bin/rsnapshot monthly>

=back

This example will do the following:

=over 4

6 hourly backups a day (once every 4 hours, at 0,4,8,12,16,20)

1 daily backup every day, at 11:50PM

4 weekly backups a month, at 11:40PM, on the 1st, 8th, 15th, and 22nd

1 monthly backup every month, at 11:30PM on the 1st day of the month

=back

Remember that these are just the times that the program runs.
To set the number of backups stored, set the interval numbers in B</etc/rsnapshot.conf>

=head1 AUTHOR

Based on code originally by Mike Rubel B<http://www.mikerubel.org/computers/rsync_snapshots/>

Rewritten and expanded in Perl by Nathan Rosenquist B<http://rsnapshot.sourceforge.net/>

Copyright (C) 2003 Nathan Rosenquist, Mike Rubel

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=head1 FILES

/etc/rsnapshot.conf

=head1 SEE ALSO

rsync(1), ssh(1), sshd(1), ssh-keygen(1), perl(1), touch(1), mkdir(1),
cp(1), mv(1), rm(1)

=head1 DIAGNOSTICS

Use the B<-t> flag to see what commands would have been executed. The
B<-v> flag will print the shell commands as they are being executed.
Much weird behavior can probably be attributed to plain old file system
permissions and ssh authentication issues.

=head1 BUGS

Swat them, or report them to rsnapshot@scubaninja.com

=head1 NOTES

Make sure your /etc/rsnapshot.conf file has all elements seperated by tabs.
See /etc/rsnapshot.conf.default for a working example file.

Make sure you put a trailing slash on the end of all directory references.
If you don't, you may have extra directories created in your snapshots.
For more information on how the trailing slash is handled, see the
B<rsync(1)> manpage.

Make sure your snapshot directory is only readable by root. If you would
like regular users to be able to restore their own backups, there are a
number of ways this can be accomplished. One such scenario would be:

Set B<snapshot_root> to B</.private/.snapshots> in B</etc/rsnapshot.conf>

Set the file permissions on these directories as follows:

=over 4

drwx------    /.private

drwxr-xr-x    /.private/.snapshots

=back

Mount the /.private/.snapshots directory over read-only NFS, a read-only
Samba share, etc.

If you do not plan on making the backups readable by regular users, be
sure to make the snapshot directory chmod 700 root. If the snapshot
directory is readable by other users, they will be able to modify the
snapshots containing their files, thus destroying the integrity of the
snapshots.

For ssh to work unattended through cron, you will probably want to use
public key logins. Create an ssh key with no passphrase for root, and
install the public key on each machine you want to backup. If you are
backing up system files from remote machines, this probably means
unattended root logins.

BE CAREFUL! If the private key is obtained by an attacker,
they will have free run of all your systems. If you are
unclear on how to do this, see B<ssh(1)>, B<sshd(1)>, and B<ssh-keygen(1)>.

rsync transfers are done using the --numeric-ids option. This means that
user names and group names are ignored during transfers, but the UID/GID
information is kept intact. The assumption is that the backups will be
restored in the same environment they came from. Without this option,
multi-server backups would be unmanageable.

If you remove backup points in the config file, they will permanently stay in
the snapshots directory unless you remove the files yourself.
If you want to conserve disk space, you will need to go into
the <snapshot_root> directory and manually remove the files from the
smallest interval's .0 directory.

For example, if you were previously
backing up /home/ in home/, and hourly is your smallest interval, you
would need to do the following to reclaim that disk space:

=over 4

rm -rf <snapshot_root>/hourly.0/home/

=back

Please note that the other snapshots previously made of /home/ will still
be using that disk space, but since the files are flushed out of hourly.0/,
they will no longer be copied to the subsequent directories, and will thus
be removed in due time as the rotations happen.

=cut

